## 20장 - 업무규칙
### 엔티티
- 컴퓨터 시스템 내부의 객체
- 핵심 업무 데이터를 기반으로 조그만 핵심 업무를 구체화해야함
- 엔티티 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 업무 규칙을 구현한함수들로 구성

### 유스케이스
- 사용자가 제공해야하는 입력, 사용자에게 보여질 출력, 해당 출력을 생성하기 위한 처리단계를 기술
- 엔티티와는 반대로, 애플리케이션에 특화된 업무규칙을 설명
- 유스케이스만 봐서는 이 애플리케이션이 웹, 리치클라이언트, 콘솔기반인지 구분하기 불가능 => 시스템에서 데이터가 들어오고 나가는 방식은 유스케이스와 무관
- 엔티티는 고수준, 유스케이스는 저수준 => 유스케이스는 단일 애플리케이션에 특화 => 보다 입력과 출력에 가깝게 위치하기 때문, 엔티티는 다양한 애플리케이션에서 사용될 수 잇도록 일반화 된 것이기 때문

### 용청 및 응답 모델
- 유스케이스는 입력 데이터를 받아서 출력 데이터를 생성
- 그러나 어떤 포맷으로 출력하는지는 상관 없음
- 의존성을 제거하는 일이 매우 중요 => 요청및 응답 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도 결국 해당 모델을 수봔하는 의존성에 간접적으로 결합되기 때문

결론. 업무규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있어야함.


## 21장 - 소리치는 아키텍처
- 시스템의 유스케이스를 지원하는 구조
- 좋은 아키텍처는 유스케이스를 중심에 두기 때문에 프레임워크나 도구환경에 구애 받지 않음
- 프레임워크, 웹(전달 메케니즘)을 선택하는 것은 세부 사항이지 아키텍처에 영향을 줘서는 안됨

## 22장 - 클린 아키텍처
- 소프트웨어의 계층을 분리함으로써 관심사의 분리를 실현 가능

- 프레임워크 독립성
- 테스트 용이성
- UI 독립성
- 데이터베이스 독립성
- 모든 외부 에이전시에 대한 독립성

### 의존성 규칙
- 소스코드의존성은 반드시 안쪽으로, 고수준의 정책을 향해야함
- 외부의 원에서 선언된 데이터 형식도 내부의 원에서 저대로 사용해서는 안됨

### 엔티티
- 전사적인 핵심 업뮤 규칙을 캡슐화

### 유스케이스
- 애플리케이션에 특화된 업무 규칙을 포함
- 시스템의 모든 유스케이스를 캡슐화 & 구현

### 인터페이스 어댑터
- 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환
- presenter, view, controller
- 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의의 프레임워크(DB)가 이용하기에 가장 편리한 형식으로 변환

### 프레임워크& 드라이버
- 모든 세부사항이 위치하는 곳. ex) 웹, 데이터베이스
- 이런것들을 모두 외부에 위치시킴으로써 피해를 최소화함 => 구조가 변경되거나 아키텍처, 엔티티, 유스케이스가 변화함에 따라 변경되는 것을 막아 변경해야하는 피해를 최소화함으로 이해


## 23장 - 프레젠터, 험블 객체
### 험블객체 패턴
- 테스트하기 어려운 행위와, 테스트 하기 쉬운 행위를 단위테스트 작성자가 분리하기 쉽게 하는 방법
- 프레젠터에는 테스트하기 쉬운 객체, 뷰에는 테스트 하기 어려운 객체이자 험블객체가 됨
- 프레젠터의 역할은 애플리케이션으로 부터 데이트를 받아 화면에 표한할 수 있는 포맷으로 만드는 것.
- 뷰는 단순히 뷰 모델의 데이터를 화면에 로드할 뿐이며, 뷰가 맡은 역할은 없음.
- 보잘것 없는 것(특별한 역할을 하지 않는 것)을 humble 이라고 하는것 같은데..?


### 테스트와 아키텍처
- 테스트 쉬운 부분과 어려운 부분으로 나누면 아키텍처의 경계가 정의 됨

### 데이터베이스 게이트웨이
- 유스케이스 계층은 SQL을 허용하지 않음
- 유스케이스 계층은 필요한 메소드를 제공하는 게이트웨이 인터페이스를 호출.
- 인터페이스의 구현체는 데이터베이스 계층에 위치
- 이러한 구현체는 험블 객체
- 서비스 - Dao 인터페이스 - Dao
- 여기서 게이트웨이 구현체는 험블객체이며 인터랙터는 험블객체가 아님. 만약 JUnit 테스트를 작성할때, Service 메소드에 대한 테스트를 작성해야 한다면 DB에서 직접 데이터를 로드하는 방식이 아닌 Stub을 통해 데이터를 작성해야 함.

### 데이터 매퍼
- 사용자관점에서 볼 때 객체는 단순히 오퍼레이션 집합
- 게이트 웨이 인터페이스와 데이터베이스사이에서 일종의 험블 객체 경계를 형성한다? => 뭔말인지 모르겠음...

### 서비스 리스너
- 데이터를 로드해서 특정 모듈로 전달하고 해당 모듈은 데이트를 적절한 포맷으로 만들어 외부 서비스로 전송
- 서비스리스너가 서비스 인터페이스로부터 데이터를 수진하고, 데이터를 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경 후 서비스 경계를 가로질러 내부로 전달


## 24장 - 부분적 경계
### 부분적 경계를 생성하는 방법
1. 단일 컴포넌트에 그대로 모아 배포 -> 외존성, 버전관리를 하지 않아도 됨

### 일차원 경계
- 스트레티지 패턴을 사용
- 중간에 인터페이스르 두어 의존성을 떨어뜨림


### 파사드
- facade 자체가 경계
- facade 클래스에 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달
- 클라이언트는 서비스 클래스에 직접 접근 x


## 25장 - 계층과 경계




