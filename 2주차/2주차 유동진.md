## 7장
### SRP 단일 책임의 원칙
- 단일 모듈은 변경의 이유가 오직 하나여야한다.
=> 하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야한다.
=> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 높은 응집도
- 매서드와 클래스 수준의 원칙. (컴포넌트 수준에서는 공통 폐쇄 원칙)


## 8장
### OCP 개방 폐쇄 원칙
- 기존의 코드를 수정하기 보다는 반드시 새로운 코드를 추가하는 방식으로 설계해야만 시스템을 쉽게 변경 할 수 있다.
- 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고, 이들 요소 사이의 의존성을 체계화함으로써 변경량을 최소화 할 수 있다.
- interactor는 다른 모든것에서 발생한 변경으로부터 보호, ocp를 가장 잘 준수할 수 있는 곳에 위치. 업무규칙을 포함하기 때문
- 시스템을 컴포넌트 단위로 분리하고, 저수준의 컴포턴트에서 발생한 변경으로 부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층 구조가 만들어지도록 해야 한다.


## 9장
### LSP 리스코프 치환 원칙
- 상호 대체 가능한 구송요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야한다는 것을 지켜야 한다.
- 상속을 사용하라.
- 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.

## 10장
### ISP 인터페이스 분리 원칙
- 사용하지 않은 것에 의존하지 않아야 한다.
- 정적 인터페이스A가 있다고 가정했을 경우, 해당 인터페이스에서 다양한 기능을 제공하는데 하나의 기능이 수정이 된다면 우리는 인터페이스A를 다시 컴파일하고 재배포를 해야하는 상황이 생길 수 있음. 이러한 상황을 방지하고자 A인터페이스는 A인터페이스를 사용하는 사용자를 기준으로 구분지어 사용자가 사용하는 기능에 대해서 인터페이스를 분리해야한다는 원칙


## 11장
### DIP 의존성 역전 원칙
- 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다.
- 구체적인 대상에는 절대로 의존해서는 안된다.
- 의존성 ㅇ관리를 하기위해 추상 팩토리 패턴을 사용하기도 
- 변동성이 큰 구체 클래스를 참조하지 마라.
- 변동성이 큰 구체 클래스로부터 파생하지 마라
- 구체 함수를 오버라이드 하지마라
